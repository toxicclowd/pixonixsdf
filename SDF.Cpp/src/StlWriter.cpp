#include "sdf/StlWriter.h"
#include <fstream>
#include <cstring>
#include <cstdint>
#include <stdexcept>
#include <iomanip>

namespace sdf {

Vector3 StlWriter::calculateNormal(const Vector3& v1, const Vector3& v2, const Vector3& v3) {
    Vector3 u = v2 - v1;
    Vector3 v = v3 - v1;
    Vector3 normal = u.cross(v);
    double len = normal.length();
    if (len < 1e-10) {
        return Vector3(0, 0, 1);  // Degenerate triangle
    }
    return normal / len;
}

void StlWriter::writeBinaryStl(const std::string& path, const std::vector<Vector3>& vertices) {
    if (vertices.size() % 3 != 0) {
        throw std::invalid_argument("Vertices count must be a multiple of 3");
    }
    
    std::ofstream file(path, std::ios::binary);
    if (!file) {
        throw std::runtime_error("Failed to open file: " + path);
    }
    
    // Write header (80 bytes)
    char header[80] = {};
    std::snprintf(header, sizeof(header), "Binary STL generated by SDF C++ library");
    file.write(header, 80);
    
    // Write triangle count
    uint32_t triangleCount = static_cast<uint32_t>(vertices.size() / 3);
    file.write(reinterpret_cast<const char*>(&triangleCount), sizeof(uint32_t));
    
    // Write triangles
    for (size_t i = 0; i < vertices.size(); i += 3) {
        const Vector3& v1 = vertices[i];
        const Vector3& v2 = vertices[i + 1];
        const Vector3& v3 = vertices[i + 2];
        
        // Calculate normal
        Vector3 normal = calculateNormal(v1, v2, v3);
        
        // Write normal (3 floats)
        float nx = static_cast<float>(normal.x);
        float ny = static_cast<float>(normal.y);
        float nz = static_cast<float>(normal.z);
        file.write(reinterpret_cast<const char*>(&nx), sizeof(float));
        file.write(reinterpret_cast<const char*>(&ny), sizeof(float));
        file.write(reinterpret_cast<const char*>(&nz), sizeof(float));
        
        // Write vertices (9 floats)
        for (int j = 0; j < 3; ++j) {
            const Vector3& v = vertices[i + j];
            float x = static_cast<float>(v.x);
            float y = static_cast<float>(v.y);
            float z = static_cast<float>(v.z);
            file.write(reinterpret_cast<const char*>(&x), sizeof(float));
            file.write(reinterpret_cast<const char*>(&y), sizeof(float));
            file.write(reinterpret_cast<const char*>(&z), sizeof(float));
        }
        
        // Write attribute byte count (always 0)
        uint16_t attributeByteCount = 0;
        file.write(reinterpret_cast<const char*>(&attributeByteCount), sizeof(uint16_t));
    }
    
    file.close();
}

void StlWriter::writeAsciiStl(const std::string& path, const std::vector<Vector3>& vertices) {
    if (vertices.size() % 3 != 0) {
        throw std::invalid_argument("Vertices count must be a multiple of 3");
    }
    
    std::ofstream file(path);
    if (!file) {
        throw std::runtime_error("Failed to open file: " + path);
    }
    
    file << std::fixed << std::setprecision(6);
    file << "solid model\n";
    
    for (size_t i = 0; i < vertices.size(); i += 3) {
        const Vector3& v1 = vertices[i];
        const Vector3& v2 = vertices[i + 1];
        const Vector3& v3 = vertices[i + 2];
        
        Vector3 normal = calculateNormal(v1, v2, v3);
        
        file << "  facet normal " << normal.x << " " << normal.y << " " << normal.z << "\n";
        file << "    outer loop\n";
        file << "      vertex " << v1.x << " " << v1.y << " " << v1.z << "\n";
        file << "      vertex " << v2.x << " " << v2.y << " " << v2.z << "\n";
        file << "      vertex " << v3.x << " " << v3.y << " " << v3.z << "\n";
        file << "    endloop\n";
        file << "  endfacet\n";
    }
    
    file << "endsolid model\n";
    file.close();
}

} // namespace sdf
